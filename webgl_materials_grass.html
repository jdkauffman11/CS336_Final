<!DOCTYPE html>
<html lang="en">
	<br>
		<title>three.js webgl - materials - grass</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#030;
				color:#fff;
				padding:0;
				margin:0;
				overflow:hidden;
				text-align:center;
			}
		</style>
	Camera controls:
	<table style="width:100%">
		<tr>
			<td>w, a, s, d - move forward, left, back, right</td>
			<td>r, f - move up, down</td>
			<td>i, j, k, l - look up, left, down, right</td>
			<td>I, J, K, L - orbit down, right, up, left</td>
			<td>O - face origin</td>
			<td>p - put camera at origin</td>
			<td>W - decrease fov</td>
			<td>S - increase fov</td>
		</tr>
	</table>

	</head>

	<body>
		<script src="three.min.js"></script>

		<script src="grass.js"></script>

	<script>
		window.onkeypress = handleKeyPress;
		var camera;
		var ch;
		function handleKeyPress(event)
		{
			ch = getChar(event);
			if (cameraControl(camera, ch)) return;

		}
		function getChar(event) {
		if (event.which == null) {
			return String.fromCharCode(event.keyCode); // IE
		} else if (event.which!=0 && event.charCode!=0) {
			return String.fromCharCode(event.which);   // the rest
		} else {
			return null; // special key
		}
	}

	function cameraControl(c, ch)
	{
		var distance = c.position.length();
		var q, q2;

		switch (ch)
		{
			// camera controls
			case 'w':
				c.translateZ(-1.0);
				return true;
			case 'a':
				c.translateX(-1.0);
				return true;
			case 's':
				c.translateZ(1.0);
				return true;
			case 'd':
				c.translateX(1.0);
				return true;
			case 'r':
				c.translateY(1.0);
				return true;
			case 'f':
				c.translateY(-1.0);
				return true;
			case 'j':
				// need to do extrinsic rotation about world y axis, so multiply camera's quaternion
				// on left
				q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0),  5 * Math.PI / 180);
				q2 = new THREE.Quaternion().copy(c.quaternion);
				c.quaternion.copy(q).multiply(q2);
				return true;
			case 'l':
				q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0),  -5 * Math.PI / 180);
				q2 = new THREE.Quaternion().copy(c.quaternion);
				c.quaternion.copy(q).multiply(q2);
				return true;
			case 'i':
				// intrinsic rotation about camera's x-axis
				c.rotateX(5 * Math.PI / 180);
				return true;
			case 'k':
				c.rotateX(-5 * Math.PI / 180);
				return true;
			case 'O':
				c.lookAt(new THREE.Vector3(0, 0, 0));
				return true;
			case 'S':
				c.fov = Math.min(80, c.fov + 5);
				c.updateProjectionMatrix();
				return true;
			case 'W':
				c.fov = Math.max(5, c.fov  - 5);
				c.updateProjectionMatrix();
				return true;

			// alternates for arrow keys
			case 'J':
				//this.orbitLeft(5, distance)
				c.translateZ(-distance);
				q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0),  5 * Math.PI / 180);
				q2 = new THREE.Quaternion().copy(c.quaternion);
				c.quaternion.copy(q).multiply(q2);
				c.translateZ(distance);
				return true;
			case 'L':
				//this.orbitRight(5, distance)
				c.translateZ(-distance);
				q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0),  -5 * Math.PI / 180);
				q2 = new THREE.Quaternion().copy(c.quaternion);
				c.quaternion.copy(q).multiply(q2);
				c.translateZ(distance);
				return true;
			case 'I':
				//this.orbitUp(5, distance)
				c.translateZ(-distance);
				c.rotateX(-5 * Math.PI / 180);
				c.translateZ(distance);
				return true;
			case 'K':
				//this.orbitDown(5, distance)
				c.translateZ(-distance);
				c.rotateX(5 * Math.PI / 180);
				c.translateZ(distance);
				return true;
		}
		return false;
	}</script>



	</body>
</html>
