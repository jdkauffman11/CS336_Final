<!DOCTYPE html>
<script src='vendor/three.js/build/three.min.js'></script>
<script src='../stats.min.js'></script>
<body style='margin: 0; overflow: hidden;'>
<div id="container"></div>
<script>
    var container, stats;

    var camera, controls, scene, renderer;

    var light, groundMesh, groundGeometry, groundMaterial, grassMeshes = [], grassGeometry, grassMaterial;

    var worldWidth = 32, worldDepth = 32,
            worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

    var grassHeight = 5, grassWidth = 2;

    var grassCount = 30000;

    var clock = new THREE.Clock();

    init();
    animate();

    function init() {

        container = document.getElementById('container');

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);

        scene = new THREE.Scene();

        scene.fog = new THREE.FogExp2(0xaaccff, 0.02);
        scene.add(new THREE.AmbientLight(0x404040));


        light = new THREE.DirectionalLight(0xffffff);
        light.position.set(0, 1, 0);
        scene.add(light);

        groundGeometry = new THREE.PlaneGeometry(worldWidth, worldDepth, worldWidth - 1, worldDepth - 1);
        groundGeometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));

        grassGeometry = new THREE.PlaneGeometry(2, 2, grassWidth - 1, grassHeight - 1);
        grassGeometry.dynamic = true;
        grassGeometry.vertices[3].z = 1;

        var groundMap = THREE.ImageUtils.loadTexture('images/grasslight-small.jpg');
        groundMap.wrapS = groundMap.wrapT = THREE.RepeatWrapping;
        groundMap.repeat.set(30, 30);

        groundMaterial = new THREE.MeshLambertMaterial({ambient: 0xbbbbbb, map: groundMap});

        var grassMap = THREE.ImageUtils.loadTexture('../images/grass01.png');

        grassMaterial = new THREE.MeshBasicMaterial({map: grassMap, alphaTest: 0.8, side: THREE.DoubleSide});

        groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.position.y = -1;
        scene.add(groundMesh);

        for (var i = 0, l = grassCount; i < l; i++) {
            grassMeshes[i] = new THREE.Mesh(grassGeometry, grassMaterial);
            grassMeshes[i].position.x = Math.random() * worldWidth - worldHalfWidth;
            grassMeshes[i].position.z = Math.random() * worldDepth - worldHalfDepth;
            grassMeshes[i].rotation.y = Math.random() * Math.PI;
            scene.add(grassMeshes[i]);
        }

        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);

        container.innerHTML = "";

        container.appendChild(renderer.domElement);

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild(stats.domElement);

        //

        window.addEventListener('resize', onWindowResize, false);

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    //

    function animate() {

        requestAnimationFrame(animate);

        render();
        stats.update();

    }

    function render() {

        var delta = clock.getDelta(),
                time = clock.getElapsedTime();

        for (var i = 0, il = grassGeometry.vertices.length / 2 - 1; i <= il; i++) {
            for (var j = 0, jl = grassWidth, f = (il - i) / il; j < jl; j++) {
                grassGeometry.vertices[jl * i + j].z = f * Math.sin(time) / 2
            }
        }

        grassGeometry.verticesNeedUpdate = true;
        renderer.render(scene, camera);

    }

    window.onkeypress = handleKeyPress;
    var ch;
    function handleKeyPress(event)
    {
        ch = getChar(event);
        if (cameraControl(camera, ch)) return;

    }
    function getChar(event) {
        if (event.which == null) {
            return String.fromCharCode(event.keyCode); // IE
        } else if (event.which!=0 && event.charCode!=0) {
            return String.fromCharCode(event.which);   // the rest
        } else {
            return null; // special key
        }
    }

    function cameraControl(c, ch)
    {
        var distance = c.position.length();
        var q, q2;

        switch (ch)
        {
            // camera controls
            case 'w':
                c.translateZ(-0.1);
                return true;
            case 'a':
                c.translateX(-0.1);
                return true;
            case 's':
                c.translateZ(0.1);
                return true;
            case 'd':
                c.translateX(0.1);
                return true;
            case 'r':
                c.translateY(0.1);
                return true;
            case 'f':
                c.translateY(-0.1);
                return true;
            case 'j':
                // need to do extrinsic rotation about world y axis, so multiply camera's quaternion
                // on left
                q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0),  5 * Math.PI / 180);
                q2 = new THREE.Quaternion().copy(c.quaternion);
                c.quaternion.copy(q).multiply(q2);
                return true;
            case 'l':
                q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0),  -5 * Math.PI / 180);
                q2 = new THREE.Quaternion().copy(c.quaternion);
                c.quaternion.copy(q).multiply(q2);
                return true;
            case 'i':
                // intrinsic rotation about camera's x-axis
                c.rotateX(5 * Math.PI / 180);
                return true;
            case 'k':
                c.rotateX(-5 * Math.PI / 180);
                return true;
            case 'S':
                c.fov = Math.min(80, c.fov + 5);
                c.updateProjectionMatrix();
                return true;
            case 'W':
                c.fov = Math.max(5, c.fov  - 5);
                c.updateProjectionMatrix();
                return true;

            // alternates for arrow keys
            case 'J':
                //this.orbitLeft(5, distance)
                c.translateZ(-distance);
                q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0),  5 * Math.PI / 180);
                q2 = new THREE.Quaternion().copy(c.quaternion);
                c.quaternion.copy(q).multiply(q2);
                c.translateZ(distance);
                return true;
            case 'L':
                //this.orbitRight(5, distance)
                c.translateZ(-distance);
                q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0),  -5 * Math.PI / 180);
                q2 = new THREE.Quaternion().copy(c.quaternion);
                c.quaternion.copy(q).multiply(q2);
                c.translateZ(distance);
                return true;
            case 'I':
                //this.orbitUp(5, distance)
                c.translateZ(-distance);
                c.rotateX(-5 * Math.PI / 180);
                c.translateZ(distance);
                return true;
            case 'K':
                //this.orbitDown(5, distance)
                c.translateZ(-distance);
                c.rotateX(5 * Math.PI / 180);
                c.translateZ(distance);
                return true;
        }
        return false;
    }
</script>
</body>
