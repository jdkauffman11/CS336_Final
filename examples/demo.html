<!DOCTYPE html>
<script src='vendor/three.js/build/three.min.js'></script>
<script src='../threex.grass.js'></script>
<body style='margin: 0; overflow: hidden;'>
<script>
    var renderer = new THREE.WebGLRenderer({
        antialias: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor('lightblue', 1);
    document.body.appendChild(renderer.domElement);

    var onRenderFcts = [];
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.01, 1000);
    camera.position.z = 1;


    //////////////////////////////////////////////////////////////////////////////////
    //		set 3 point lighting						//
    //////////////////////////////////////////////////////////////////////////////////

    (function () {
        // add a ambient light
        var light = new THREE.AmbientLight(0x020202);
        scene.add(light);
        // add a light in front
        light = new THREE.DirectionalLight('white', 1);
        light.position.set(0.5, 0.5, 2);
        scene.add(light);
        // add a light behind
        light = new THREE.DirectionalLight('white', 0.75);
        light.position.set(-0.5, -0.5, -2);
        scene.add(light)
    })();

    // add a light behind
    var light = new THREE.DirectionalLight('white', 1);
    // var light	= new THREE.PointLight('white', 2)
    scene.add(light);
    light.position.y = 1;
    onRenderFcts.push(function (delta, now) {
        var angle = now * Math.PI * 2 * 0.2;
        light.position.x = Math.cos(angle) * 3;
        light.position.y = Math.sin(angle) * 3;
        // light.position.z= Math.sin(angle)*3
    });

    //////////////////////////////////////////////////////////////////////////////////
    //		grass ground							//
    //////////////////////////////////////////////////////////////////////////////////

    var textureUrl = 'images/grasslight-small.jpg';
    var texture = THREE.ImageUtils.loadTexture(textureUrl);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.x = 10;
    texture.repeat.y = 10;
    texture.anisotropy = renderer.getMaxAnisotropy();

    // build object3d
    var geometry = new THREE.PlaneGeometry(20, 20);
    var material = new THREE.MeshPhongMaterial({
        map: texture,
        emissive: 'green'
    });
    var object3d = new THREE.Mesh(geometry, material);
    object3d.rotateX(-Math.PI / 2);
    scene.add(object3d);


    //////////////////////////////////////////////////////////////////////////////////
    //		comment								//
    //////////////////////////////////////////////////////////////////////////////////

    var nTufts = 5000;
    var positions = new Array(nTufts);
    for (var i = 0; i < nTufts; i++) {
        var position = new THREE.Vector3();
        position.x = (Math.random() - 0.5) * 20;
        position.z = (Math.random() - 0.5) * 20;
        positions[i] = position
    }
    var mesh = THREEx.createGrassTufts(positions);
    scene.add(mesh);

    // load the texture
    textureUrl = THREEx.createGrassTufts.baseUrl + 'images/grass01.png';
    material = mesh.material;
    material.map = THREE.ImageUtils.loadTexture(textureUrl);
    material.alphaTest = 0.7;

    //////////////////////////////////////////////////////////////////////////////////
    //		comment								//
    //////////////////////////////////////////////////////////////////////////////////


    nTufts = 5000;
    positions = new Array(nTufts);
    for (i = 0; i < nTufts; i++) {
        position = new THREE.Vector3();
        position.x = (Math.random() - 0.5) * 20;
        position.z = (Math.random() - 0.5) * 20;
        positions[i] = position
    }
    mesh = THREEx.createGrassTufts(positions);
    scene.add(mesh);

    // load the texture
    textureUrl = THREEx.createGrassTufts.baseUrl + 'images/grass02.png';
    material = mesh.material;
    material.map = THREE.ImageUtils.loadTexture(textureUrl);
    material.alphaTest = 0.7;

    //////////////////////////////////////////////////////////////////////////////////
    //		comment								//
    //////////////////////////////////////////////////////////////////////////////////
    nTufts = 100;
    positions = new Array(nTufts);
    for (i = 0; i < nTufts; i++) {
        position = new THREE.Vector3();
        position.x = (Math.random() - 0.5) * 20;
        position.z = (Math.random() - 0.5) * 20;
        positions[i] = position;
    }
    mesh = THREEx.createGrassTufts(positions);
    scene.add(mesh);

    // load the texture
    material = mesh.material;
    textureUrl = THREEx.createGrassTufts.baseUrl + 'images/flowers01.png';
    material.map = THREE.ImageUtils.loadTexture(textureUrl);
    material.emissive.set(0x888888);
    material.alphaTest = 0.7;

    //////////////////////////////////////////////////////////////////////////////////
    //		comment								//
    //////////////////////////////////////////////////////////////////////////////////
    nTufts = 100;
    positions = new Array(nTufts);
    for (i = 0; i < nTufts; i++) {
        position = new THREE.Vector3();
        position.x = (Math.random() - 0.5) * 20;
        position.z = (Math.random() - 0.5) * 20;
        positions[i] = position
    }
    mesh = THREEx.createGrassTufts(positions);
    scene.add(mesh);

    // load the texture
    material = mesh.material;
    textureUrl = THREEx.createGrassTufts.baseUrl + 'images/flowers02.png';
    material.map = THREE.ImageUtils.loadTexture(textureUrl);
    material.emissive.set(0x888888);
    material.alphaTest = 0.7;


    //////////////////////////////////////////////////////////////////////////////////
    //		Camera Controls							//
    //////////////////////////////////////////////////////////////////////////////////
    window.onkeypress = handleKeyPress;
    var ch;

    //////////////////////////////////////////////////////////////////////////////////
    //		render the scene						//
    //////////////////////////////////////////////////////////////////////////////////
    onRenderFcts.push(function () {
        renderer.render(scene, camera);
    });

    //////////////////////////////////////////////////////////////////////////////////
    //		loop runner							//
    //////////////////////////////////////////////////////////////////////////////////
    var lastTimeMsec = null;
    requestAnimationFrame(function animate(nowMsec) {
        // keep looping
        requestAnimationFrame(animate);
        // measure time
        lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60;
        var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
        lastTimeMsec = nowMsec;
        // call each update function
        onRenderFcts.forEach(function (onRenderFct) {
            onRenderFct(deltaMsec / 1000, nowMsec / 1000)
        })
    });

    function handleKeyPress(event) {
        ch = getChar(event);
        if (cameraControl(camera, ch)) return;

    }

    function getChar(event) {
        if (event.which == null) {
            return String.fromCharCode(event.keyCode); // IE
        } else if (event.which!=0 && event.charCode!=0) {
            return String.fromCharCode(event.which);   // the rest
        } else {
            return null; // special key
        }
    }

    function cameraControl(c, ch) {
        var distance = c.position.length();
        var q, q2;

        switch (ch) {
            // camera controls
            case 'w':
                c.translateZ(-0.01);
                return true;
            case 'a':
                c.translateX(-0.01);
                return true;
            case 's':
                c.translateZ(0.01);
                return true;
            case 'd':
                c.translateX(0.01);
                return true;
            case 'r':
                c.translateY(0.01);
                return true;
            case 'f':
                c.translateY(-0.01);
                return true;
            case 'j':
                // need to do extrinsic rotation about world y axis, so multiply camera's quaternion
                // on left
                q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 180);
                q2 = new THREE.Quaternion().copy(c.quaternion);
                c.quaternion.copy(q).multiply(q2);
                return true;
            case 'l':
                q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), -Math.PI / 180);
                q2 = new THREE.Quaternion().copy(c.quaternion);
                c.quaternion.copy(q).multiply(q2);
                return true;
            case 'i':
                // intrinsic rotation about camera's x-axis
                c.rotateX(5 * Math.PI / 180);
                return true;
            case 'k':
                c.rotateX(-5 * Math.PI / 180);
                return true;
            case 'S':
                c.fov = Math.min(80, c.fov + 5);
                c.updateProjectionMatrix();
                return true;
            case 'W':
                c.fov = Math.max(5, c.fov - 5);
                c.updateProjectionMatrix();
                return true;

            // alternates for arrow keys
            case 'J':
                //this.orbitLeft(5, distance)
                c.translateZ(-distance);
                q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), 5 * Math.PI / 180);
                q2 = new THREE.Quaternion().copy(c.quaternion);
                c.quaternion.copy(q).multiply(q2);
                c.translateZ(distance);
                return true;
            case 'L':
                //this.orbitRight(5, distance)
                c.translateZ(-distance);
                q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), -5 * Math.PI / 180);
                q2 = new THREE.Quaternion().copy(c.quaternion);
                c.quaternion.copy(q).multiply(q2);
                c.translateZ(distance);
                return true;
            case 'I':
                //this.orbitUp(5, distance)
                c.translateZ(-distance);
                c.rotateX(-5 * Math.PI / 180);
                c.translateZ(distance);
                return true;
            case 'K':
                //this.orbitDown(5, distance)
                c.translateZ(-distance);
                c.rotateX(5 * Math.PI / 180);
                c.translateZ(distance);
                return true;
        }
        return false;
    }

</script>
</body>
